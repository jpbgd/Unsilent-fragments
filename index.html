<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <title>Silent Fragments</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;500&family=Lora:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { 
      --accent-blue: #0b385f; 
      --text-dark: #1A1A1A;
      --text-medium: #333333;
      --bg-cream: #FAF9F6;
    }
    html, body {
      margin: 0; padding: 0; overflow: hidden; position: fixed;
      width: 100%; height: 100%; background: var(--bg-cream);
      -webkit-user-select: none; -moz-user-select: none; user-select: none;
    }
    body { cursor: none; }
    * { cursor: none !important; box-sizing: border-box; }
    img { pointer-events: none; -webkit-user-drag: none; }
    input, textarea { font-size: 16px !important; }
    #root:empty { display: none; }
    #root { opacity: 0; animation: fadeIn 0.3s ease-in 0.1s forwards; }
    @keyframes fadeIn { to { opacity: 1; } }
    
    .font-loader {
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      letter-spacing: 0.08em;
      color: var(--text-dark);
    }
    
    .font-ui {
      font-family: 'Inter', sans-serif;
      font-weight: 100;
      letter-spacing: 0.08em;
      color: var(--text-medium);
    }
    
    .font-body {
      font-family: 'Lora', serif;
      font-weight: 400;
    }
    
    textarea::placeholder { 
      color: rgba(255,255,255,0.6); 
      font-family: 'Lora', serif;
    }
    textarea.bright-bg::placeholder { 
      color: rgba(0,0,0,0.4); 
    }
  </style>
</head>
<body oncontextmenu="return false;">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const PhotoViewer = () => {
      const projectTitle = "Silent Fragments";
      const githubUser = "jpbgd";
      const githubRepo = "Silent-fragments";
      const githubBranch = "main";
      const STORAGE_KEY = 'silentFragmentsComments';
      const MAX_COMMENTS = 500;

      // Core states
      const [photos, setPhotos] = useState([]);
      const [loading, setLoading] = useState(true);
      const [showIntro, setShowIntro] = useState(true);
      const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);
      const [randomOrder, setRandomOrder] = useState([]);
      const [imageLoaded, setImageLoaded] = useState(false);
      const [isMobile, setIsMobile] = useState(false);
      const [isImageBright, setIsImageBright] = useState(false);

      // UI states
      const [showCommentBox, setShowCommentBox] = useState(false);
      const [showContactSheet, setShowContactSheet] = useState(false);
      const [showCommentsView, setShowCommentsView] = useState(false);
      const [hoveredElement, setHoveredElement] = useState(null);
      const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });

      // Comment states
      const [commentText, setCommentText] = useState('');
      const [dissolving, setDissolving] = useState(false);
      const [dissolveText, setDissolveText] = useState('');
      const [dissolveOpacity, setDissolveOpacity] = useState(1);
      const [showMergedMessage, setShowMergedMessage] = useState(false);
      const [mergedMessageOpacity, setMergedMessageOpacity] = useState(0);
      const [photoComments, setPhotoComments] = useState({});

      // Contact sheet states
      const [imagePositions, setImagePositions] = useState([]);
      const [draggingIndex, setDraggingIndex] = useState(null);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
      const [zIndexOrder, setZIndexOrder] = useState([]);
      const [hoveredThumbnail, setHoveredThumbnail] = useState(null);
      const [pinchingIndex, setPinchingIndex] = useState(null);
      const [activeImageIndex, setActiveImageIndex] = useState(null);
      const [showScreensaver, setShowScreensaver] = useState(false);
      const [screensaverPosition, setScreensaverPosition] = useState({ x: 0, y: 0 });
      const inactivityTimer = useRef(null);

      // Swipe states
      const [swipeStart, setSwipeStart] = useState(null);
      const [swipeOffset, setSwipeOffset] = useState(0);
      const [isSwipeTransitioning, setIsSwipeTransitioning] = useState(false);

      // Refs
      const longPressTimer = useRef(null);
      const isLongPress = useRef(false);
      const wasDragging = useRef(false);
      const initialPinchDistance = useRef(0);
      const initialImageWidth = useRef(0);
      const initialPinchCenter = useRef({ x: 0, y: 0 });
      const initialImagePos = useRef({ x: 0, y: 0 });
      const lastClickTime = useRef(0);
      const textareaRef = useRef(null);
      const commentBoxRef = useRef(null);

      // Photo files
      const photoFiles = [
        'Untitled_250619.jpg', 'Untitled_241221.jpg', 'Untitiled_241208.jpg',
        'Untitiled_241115.jpg', 'Untitiled_240714.jpg'
      ];

      // Initialize
      useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768 || 'ontouchstart' in window);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
      }, []);

      useEffect(() => {
        const photosList = photoFiles.map((fileName, index) => {
          const parts = fileName.replace(/\.[^/.]+$/, "").split('_');
          return {
            id: index,
            url: `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/${githubBranch}/${fileName}`,
            title: parts[0] || 'Untitled',
            date: parts[1] || ''
          };
        });
        setPhotos(photosList);
        setLoading(false);
      }, []);

      useEffect(() => {
        if (photos.length > 0) {
          setRandomOrder([...Array(photos.length).keys()].sort(() => Math.random() - 0.5));
        }
      }, [photos]);

      useEffect(() => {
        const timer = setTimeout(() => setShowIntro(false), 1500);
        return () => clearTimeout(timer);
      }, []);

      useEffect(() => { setImageLoaded(false); }, [currentPhotoIndex]);

      // Load/save comments
      useEffect(() => {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) setPhotoComments(JSON.parse(saved));
        } catch (e) {}
      }, []);

      useEffect(() => {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(photoComments)); } catch (e) {}
      }, [photoComments]);

      // Brightness detection
      useEffect(() => {
        if (!photos[randomOrder[currentPhotoIndex]]) return;
        const currentPhoto = photos[randomOrder[currentPhotoIndex]];
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = currentPhoto.url;
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = canvas.height = 50;
          ctx.drawImage(img, 0, 0, 50, 50);
          try {
            const data = ctx.getImageData(0, 0, 50, 50).data;
            let total = 0;
            for (let i = 0; i < data.length; i += 4) {
              total += (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            }
            setIsImageBright(total / 2500 > 140);
          } catch (e) { setIsImageBright(false); }
        };
      }, [currentPhotoIndex, photos, randomOrder]);

      // Mouse tracking
      useEffect(() => {
        const handleMouseMove = (e) => {
          setCursorPosition({ x: e.clientX, y: e.clientY });
        };
        window.addEventListener('mousemove', handleMouseMove);
        return () => window.removeEventListener('mousemove', handleMouseMove);
      }, []);

      // Screensaver - inactivity detection (15 seconds)
      useEffect(() => {
        const resetInactivity = () => {
          if (showScreensaver) {
            setShowScreensaver(false);
          }
          if (inactivityTimer.current) {
            clearTimeout(inactivityTimer.current);
          }
          inactivityTimer.current = setTimeout(() => {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const videoWidth = vw * 0.7;
            const videoHeight = vh * 0.7;
            setScreensaverPosition({
              x: Math.random() * (vw - videoWidth),
              y: Math.random() * (vh - videoHeight)
            });
            setShowScreensaver(true);
          }, 15000);
        };

        resetInactivity();
        
        const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'];
        events.forEach(event => window.addEventListener(event, resetInactivity));
        
        return () => {
          if (inactivityTimer.current) clearTimeout(inactivityTimer.current);
          events.forEach(event => window.removeEventListener(event, resetInactivity));
        };
      }, [showScreensaver]);

      // Contact sheet positions
      const initializePositions = useCallback(() => {
        if (!photos.length) return;
        const isMobileView = window.innerWidth <= 768;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        
        const zones = isMobileView ? [
          { x: 0.08, y: 0.08 }, { x: 0.55, y: 0.12 },
          { x: 0.12, y: 0.42 }, { x: 0.52, y: 0.48 },
          { x: 0.30, y: 0.72 }
        ] : [
          { x: 0.05, y: 0.05 }, { x: 0.55, y: 0.08 },
          { x: 0.08, y: 0.45 }, { x: 0.58, y: 0.50 },
          { x: 0.30, y: 0.28 }
        ];
        
        const shuffledZones = [...zones].sort(() => Math.random() - 0.5);
        
        const positions = photos.map((_, index) => {
          const zone = shuffledZones[index % shuffledZones.length];
          const randX = (Math.random() - 0.5) * 0.1;
          const randY = (Math.random() - 0.5) * 0.1;
          const baseWidth = isMobileView ? 0.38 : 0.26;
          const randWidth = (Math.random() - 0.5) * 0.08;
          
          return {
            x: (zone.x + randX) * vw,
            y: (zone.y + randY) * vh,
            width: (baseWidth + randWidth) * vw
          };
        });
        
        setImagePositions(positions);
        setZIndexOrder([...Array(photos.length).keys()].sort(() => Math.random() - 0.5));
      }, [photos]);

      useEffect(() => {
        if (photos.length > 0 && showContactSheet) initializePositions();
      }, [photos, showContactSheet, initializePositions]);

      // Navigation handlers
      const handleNextPhoto = useCallback(() => {
        if (!randomOrder.length) return;
        setCurrentPhotoIndex(prev => (prev + 1) % randomOrder.length);
      }, [randomOrder.length]);

      const handlePrevPhoto = useCallback(() => {
        if (!randomOrder.length) return;
        setCurrentPhotoIndex(prev => (prev - 1 + randomOrder.length) % randomOrder.length);
      }, [randomOrder.length]);

      // Swipe handlers for main photo view
      const handleSwipeStart = useCallback((clientX) => {
        if (showCommentBox || showContactSheet || showCommentsView) return;
        setSwipeStart(clientX);
        setSwipeOffset(0);
      }, [showCommentBox, showContactSheet, showCommentsView]);

      const handleSwipeMove = useCallback((clientX) => {
        if (swipeStart === null || isSwipeTransitioning) return;
        const diff = clientX - swipeStart;
        setSwipeOffset(diff);
      }, [swipeStart, isSwipeTransitioning]);

      const handleSwipeEnd = useCallback(() => {
        if (swipeStart === null) return;
        
        const threshold = window.innerWidth * 0.15;
        
        if (Math.abs(swipeOffset) > threshold) {
          setIsSwipeTransitioning(true);
          const direction = swipeOffset > 0 ? -1 : 1;
          
          if (direction > 0) {
            handleNextPhoto();
          } else {
            handlePrevPhoto();
          }
          
          setTimeout(() => {
            setSwipeOffset(0);
            setIsSwipeTransitioning(false);
          }, 300);
        } else {
          setSwipeOffset(0);
        }
        
        setSwipeStart(null);
      }, [swipeStart, swipeOffset, handleNextPhoto, handlePrevPhoto]);

      // Mouse swipe (desktop)
      const handleMouseDown = useCallback((e) => {
        if (e.target.closest('button') || e.target.closest('textarea')) return;
        handleSwipeStart(e.clientX);
      }, [handleSwipeStart]);

      const handleMouseMove = useCallback((e) => {
        handleSwipeMove(e.clientX);
      }, [handleSwipeMove]);

      const handleMouseUp = useCallback(() => {
        handleSwipeEnd();
      }, [handleSwipeEnd]);

      // Touch swipe (mobile)
      const handleTouchStartSwipe = useCallback((e) => {
        if (e.target.closest('button') || e.target.closest('textarea')) return;
        if (e.touches.length === 1) {
          handleSwipeStart(e.touches[0].clientX);
        }
      }, [handleSwipeStart]);

      const handleTouchMoveSwipe = useCallback((e) => {
        if (e.touches.length === 1) {
          handleSwipeMove(e.touches[0].clientX);
        }
      }, [handleSwipeMove]);

      const handleTouchEndSwipe = useCallback(() => {
        handleSwipeEnd();
      }, [handleSwipeEnd]);

      // Image tap opens comment box on mobile
      const handleImageTap = useCallback((e) => {
        if (isMobile) {
          e.stopPropagation();
          setShowCommentBox(true);
        }
      }, [isMobile]);

      const handleTitleClick = (e) => {
        e.stopPropagation();
        setShowIntro(true);
        setTimeout(() => setShowIntro(false), 3000);
      };

      const handleSubmitComment = () => {
        if (!commentText.trim()) return;
        const textToSave = commentText.trim();
        const currentPhoto = photos[randomOrder[currentPhotoIndex]];
        
        setDissolveText(textToSave);
        setCommentText('');
        setDissolving(true);
        setDissolveOpacity(1);

        setPhotoComments(prev => {
          const curr = prev[currentPhoto.id] || [];
          const newComments = curr.length >= MAX_COMMENTS ? [...curr.slice(1), textToSave] : [...curr, textToSave];
          return { ...prev, [currentPhoto.id]: newComments };
        });

        // 2 second fade out for text
        requestAnimationFrame(() => setDissolveOpacity(0));
        
        setTimeout(() => {
          setDissolving(false);
          setDissolveText('');
          setShowMergedMessage(true);
          setMergedMessageOpacity(1);
          
          // 2 second display then fade out merged message
          setTimeout(() => {
            setMergedMessageOpacity(0);
            setTimeout(() => {
              setShowMergedMessage(false);
              setShowCommentBox(false);
            }, 500);
          }, 1500);
        }, 2000);
      };

      // Close comment box when clicking outside
      const handleCommentBoxOutsideClick = useCallback((e) => {
        if (commentBoxRef.current && !commentBoxRef.current.contains(e.target)) {
          if (!dissolving && !showMergedMessage) {
            setShowCommentBox(false);
            setCommentText('');
          }
        }
      }, [dissolving, showMergedMessage]);

      // Contact sheet - Desktop handlers
      const handleImageMouseDown = (e, index) => {
        e.preventDefault();
        e.stopPropagation();
        lastClickTime.current = Date.now();
        
        longPressTimer.current = setTimeout(() => {
          isLongPress.current = true;
          wasDragging.current = true;
          setDragOffset({
            x: e.clientX - imagePositions[index].x,
            y: e.clientY - imagePositions[index].y
          });
          setDraggingIndex(index);
          setZIndexOrder(prev => [...prev.filter(i => i !== index), index]);
        }, 150);
      };

      const handleImageMouseUp = (e, index) => {
        if (longPressTimer.current) clearTimeout(longPressTimer.current);
        
        const clickDuration = Date.now() - lastClickTime.current;
        
        if (draggingIndex === index) {
          e.stopPropagation();
          setDraggingIndex(null);
          setTimeout(() => { wasDragging.current = false; isLongPress.current = false; }, 50);
        } else if (clickDuration < 200 && !isLongPress.current && !wasDragging.current) {
          setCurrentPhotoIndex(randomOrder.indexOf(index));
          setShowContactSheet(false);
        }
      };

      useEffect(() => {
        if (draggingIndex === null) return;
        
        const handleMove = (e) => {
          const newPositions = [...imagePositions];
          newPositions[draggingIndex] = {
            ...newPositions[draggingIndex],
            x: e.clientX - dragOffset.x,
            y: e.clientY - dragOffset.y
          };
          setImagePositions(newPositions);
        };
        
        const handleUp = () => {
          setDraggingIndex(null);
          setTimeout(() => { wasDragging.current = false; isLongPress.current = false; }, 50);
        };

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleUp);
        return () => {
          window.removeEventListener('mousemove', handleMove);
          window.removeEventListener('mouseup', handleUp);
        };
      }, [draggingIndex, dragOffset, imagePositions]);

      // Contact sheet - Mobile handlers with free zoom
      const handleImageTouchStart = (e, index) => {
        if (activeImageIndex !== null && activeImageIndex !== index) return;
        
        if (longPressTimer.current) clearTimeout(longPressTimer.current);
        
        if (e.touches.length === 2 && (activeImageIndex === null || activeImageIndex === index)) {
          e.preventDefault();
          const t1 = e.touches[0], t2 = e.touches[1];
          const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          const cx = (t1.clientX + t2.clientX) / 2, cy = (t1.clientY + t2.clientY) / 2;
          initialPinchDistance.current = dist;
          initialImageWidth.current = imagePositions[index]?.width || 100;
          initialPinchCenter.current = { x: cx, y: cy };
          initialImagePos.current = { x: imagePositions[index]?.x || 0, y: imagePositions[index]?.y || 0 };
          setPinchingIndex(index);
          setActiveImageIndex(index);
          setDraggingIndex(null);
          setZIndexOrder(prev => [...prev.filter(i => i !== index), index]);
          return;
        }

        const touch = e.touches[0];
        e.target._touchStartX = touch.clientX;
        e.target._touchStartY = touch.clientY;
        e.target._touchStartTime = Date.now();

        longPressTimer.current = setTimeout(() => {
          isLongPress.current = true;
          wasDragging.current = true;
          setDragOffset({ x: touch.clientX - imagePositions[index].x, y: touch.clientY - imagePositions[index].y });
          setDraggingIndex(index);
          setActiveImageIndex(index);
          setZIndexOrder(prev => [...prev.filter(i => i !== index), index]);
        }, 150);
      };

      const handleImageTouchMove = (e, index) => {
        if (activeImageIndex !== null && activeImageIndex !== index) return;
        
        if (e.touches.length === 2) {
          e.preventDefault();
          if (longPressTimer.current) clearTimeout(longPressTimer.current);
          
          const targetIndex = activeImageIndex !== null ? activeImageIndex : index;
          setDraggingIndex(null);
          
          const t1 = e.touches[0], t2 = e.touches[1];
          const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          const cx = (t1.clientX + t2.clientX) / 2, cy = (t1.clientY + t2.clientY) / 2;
          
          if (pinchingIndex !== targetIndex) {
            initialPinchDistance.current = dist;
            initialImageWidth.current = imagePositions[targetIndex]?.width || 100;
            initialPinchCenter.current = { x: cx, y: cy };
            initialImagePos.current = { x: imagePositions[targetIndex]?.x || 0, y: imagePositions[targetIndex]?.y || 0 };
            setPinchingIndex(targetIndex);
            setActiveImageIndex(targetIndex);
            setZIndexOrder(prev => [...prev.filter(i => i !== targetIndex), targetIndex]);
          } else {
            const scale = dist / initialPinchDistance.current;
            // Free zoom - no upper limit, image can exceed screen bounds
            const newWidth = Math.max(60, initialImageWidth.current * scale);
            const deltaX = cx - initialPinchCenter.current.x;
            const deltaY = cy - initialPinchCenter.current.y;
            const newPositions = [...imagePositions];
            newPositions[targetIndex] = { 
              ...newPositions[targetIndex], 
              width: newWidth, 
              x: initialImagePos.current.x + deltaX, 
              y: initialImagePos.current.y + deltaY 
            };
            setImagePositions(newPositions);
          }
          return;
        }

        if (draggingIndex === index && e.touches.length === 1) {
          e.preventDefault();
          const touch = e.touches[0];
          const newPositions = [...imagePositions];
          newPositions[index] = { ...newPositions[index], x: touch.clientX - dragOffset.x, y: touch.clientY - dragOffset.y };
          setImagePositions(newPositions);
        } else if (!isLongPress.current && longPressTimer.current) {
          clearTimeout(longPressTimer.current);
        }
      };

      const handleImageTouchEnd = (e, index) => {
        if (longPressTimer.current) clearTimeout(longPressTimer.current);
        
        if (activeImageIndex !== null && activeImageIndex !== index) return;
        
        if (pinchingIndex === index) {
          setPinchingIndex(null);
          setActiveImageIndex(null);
          initialPinchDistance.current = 0;
          return;
        }
        
        if (draggingIndex === index) {
          e.preventDefault();
          setDraggingIndex(null);
          setActiveImageIndex(null);
          setTimeout(() => { isLongPress.current = false; wasDragging.current = false; }, 100);
          return;
        }

        const diffX = Math.abs((e.changedTouches[0]?.clientX || 0) - (e.target._touchStartX || 0));
        const diffY = Math.abs((e.changedTouches[0]?.clientY || 0) - (e.target._touchStartY || 0));
        const duration = Date.now() - (e.target._touchStartTime || 0);
        
        if (diffX < 15 && diffY < 15 && duration < 300 && !isLongPress.current && !wasDragging.current) {
          setCurrentPhotoIndex(randomOrder.indexOf(index));
          setShowContactSheet(false);
        }
        
        setActiveImageIndex(null);
      };

      // Render
      if (loading || !photos.length || !randomOrder.length) {
        return <div className="w-screen h-screen flex items-center justify-center fixed inset-0" style={{ backgroundColor: '#FAF9F6' }}>
          <p className="font-loader text-sm">{loading ? 'Loading...' : 'No photos found'}</p>
        </div>;
      }

      const currentPhoto = photos[randomOrder[currentPhotoIndex]];
      const isHovering = (el) => hoveredElement === el;
      const textColor = (el) => isHovering(el) ? '#0b385f' : '#333333';
      const textOpacity = (el) => isHovering(el) ? 1 : 0.7;

      // Custom cursor component
      const CustomCursor = ({ isClickable }) => (
        <div className="fixed pointer-events-none" style={{
          left: cursorPosition.x, 
          top: cursorPosition.y, 
          transform: 'translate(-50%, -50%)',
          width: 12, 
          height: 12, 
          borderRadius: '50%', 
          zIndex: 10000,
          backgroundColor: isClickable ? '#0b385f' : 'white',
          border: isClickable ? 'none' : '1.5px solid #1A1A1A',
          boxShadow: isClickable ? 'none' : '0 1px 4px rgba(0,0,0,0.2)',
          transition: 'background-color 0.2s, border 0.2s, box-shadow 0.2s'
        }} />
      );

      return (
        <div 
          className="w-screen relative" 
          style={{ 
            cursor: 'none', 
            overflow: 'hidden', 
            position: 'fixed', 
            inset: 0, 
            touchAction: 'pan-y',
            backgroundColor: '#FAF9F6'
          }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
          onTouchStart={handleTouchStartSwipe}
          onTouchMove={handleTouchMoveSwipe}
          onTouchEnd={handleTouchEndSwipe}
        >
          
          {!isMobile && <CustomCursor isClickable={hoveredElement !== null} />}

          {/* Intro screen */}
          <div className={`absolute inset-0 flex items-center justify-center z-50 ${showIntro ? 'opacity-100' : 'opacity-0'}`}
            style={{ transition: 'opacity 2s ease-out', pointerEvents: showIntro ? 'auto' : 'none', backgroundColor: '#FAF9F6' }}>
            <h1 className="font-loader text-2xl md:text-4xl px-4 text-center">{projectTitle}</h1>
          </div>

          {!showIntro && currentPhoto && (
            <div 
              className="w-full flex flex-col items-center justify-between" 
              style={{ 
                height: '100%', 
                padding: isMobile ? '12px' : '24px', 
                overflow: 'hidden',
                transform: `translateX(${swipeOffset}px)`,
                transition: isSwipeTransitioning ? 'transform 0.3s ease-out' : 'none'
              }}
            >
              
              {/* Header */}
              <div className="w-full text-center cursor-pointer flex-shrink-0" onClick={handleTitleClick}
                onMouseEnter={() => setHoveredElement('title')} onMouseLeave={() => setHoveredElement(null)}>
                <h2 className="font-ui text-sm md:text-base transition-all"
                  style={{ color: isHovering('title') ? '#0b385f' : '#333333', opacity: textOpacity('title') }}>{projectTitle}</h2>
              </div>

              {/* Main photo */}
              <div 
                className="flex items-center justify-center w-full"
                style={{ 
                  flex: '1 1 auto', 
                  maxWidth: isMobile ? '100%' : '42rem', 
                  minHeight: 0, 
                  overflow: 'hidden', 
                  padding: isMobile ? '8px 0' : '16px 0',
                  cursor: isMobile ? 'pointer' : 'none'
                }}
                onClick={handleImageTap}
              >
                <img 
                  src={currentPhoto.url} 
                  alt={currentPhoto.title} 
                  className="object-contain"
                  style={{ 
                    maxWidth: '100%', 
                    maxHeight: '100%', 
                    boxShadow: '0 4px 20px rgba(0,0,0,0.08)', 
                    touchAction: 'pan-x pan-y'
                  }} 
                />
              </div>

              {/* Footer */}
              <div className="w-full flex-shrink-0" style={{ paddingTop: isMobile ? '8px' : '12px', position: 'relative', zIndex: 5 }}>
                <div className="flex items-center w-full">
                  <div className="flex-1 flex justify-start">
                    <button onClick={(e) => { e.stopPropagation(); setShowContactSheet(true); }}
                      onMouseEnter={() => setHoveredElement('contact')} onMouseLeave={() => setHoveredElement(null)}
                      className="transition-all" style={{ color: textColor('contact'), opacity: textOpacity('contact') }}>
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="7" cy="7" r="2.5"/><circle cx="17" cy="7" r="2.5"/><circle cx="7" cy="17" r="2.5"/><circle cx="17" cy="17" r="2.5"/>
                      </svg>
                    </button>
                  </div>
                  <div className="flex-1 flex justify-center">
                    <button onClick={(e) => { e.stopPropagation(); setShowCommentBox(true); }}
                      onMouseEnter={() => setHoveredElement('share')} onMouseLeave={() => setHoveredElement(null)}
                      className="font-ui transition-all"
                      style={{ 
                        fontSize: isMobile ? 11 : 12, 
                        color: textColor('share'), 
                        opacity: textOpacity('share'),
                        textDecoration: 'underline',
                        textUnderlineOffset: '3px'
                      }}>
                      Lend your words
                    </button>
                  </div>
                  <div className="flex-1 flex justify-end">
                    <button onClick={(e) => { e.stopPropagation(); setShowCommentsView(true); }}
                      onMouseEnter={() => setHoveredElement('photoTitle')} onMouseLeave={() => setHoveredElement(null)}
                      className="font-ui transition-all text-right"
                      style={{ 
                        fontSize: isMobile ? 11 : 12, 
                        color: textColor('photoTitle'), 
                        opacity: textOpacity('photoTitle'), 
                        background: 'none', 
                        border: 'none', 
                        padding: '4px', 
                        margin: '-4px', 
                        pointerEvents: 'auto', 
                        position: 'relative', 
                        zIndex: 10 
                      }}>
                      {currentPhoto.date}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Comment box overlay */}
          {showCommentBox && (
            <div 
              className="fixed z-50" 
              onClick={handleCommentBoxOutsideClick}
              style={{ 
                inset: 0, 
                backgroundColor: 'rgba(250,249,246,0.02)', 
                backdropFilter: 'blur(0.5px)', 
                display: 'flex', 
                alignItems: 'center', 
                justifyContent: 'center' 
              }}
            >
              <div 
                ref={commentBoxRef}
                style={{ 
                  width: '90%', 
                  maxWidth: isMobile ? '100%' : '42rem',
                  textAlign: 'center',
                  padding: '0 20px'
                }} 
                onClick={(e) => e.stopPropagation()}
              >
                <div style={{ position: 'relative', minHeight: 150, maxHeight: '60vh' }}>
                  {!showMergedMessage && !dissolving && (
                    <textarea 
                      ref={textareaRef}
                      value={commentText} 
                      onChange={(e) => setCommentText(e.target.value)} 
                      autoFocus
                      placeholder="write down what you're thinking..."
                      className={`font-body ${isImageBright ? 'bright-bg' : ''}`}
                      data-gramm="false"
                      data-gramm_editor="false"
                      data-enable-grammarly="false"
                      spellCheck="false"
                      autoComplete="off"
                      autoCorrect="off"
                      autoCapitalize="off"
                      style={{ 
                        width: '100%', 
                        minHeight: 150,
                        maxHeight: '50vh',
                        background: 'transparent', 
                        border: 'none', 
                        outline: 'none', 
                        resize: 'none', 
                        textAlign: 'center', 
                        fontSize: 16, 
                        fontWeight: 400, 
                        lineHeight: 1.8,
                        padding: '20px 10px',
                        cursor: isMobile ? 'auto' : 'none', 
                        color: isImageBright ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.95)', 
                        textShadow: isImageBright ? 'none' : '0 1px 3px rgba(0,0,0,0.3)',
                        overflow: 'auto'
                      }} 
                    />
                  )}
                  {dissolving && (
                    <div style={{ 
                      width: '100%',
                      minHeight: 150,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      padding: '20px 10px'
                    }}>
                      <p className="font-body" style={{ 
                        margin: 0, 
                        fontSize: 16, 
                        fontWeight: 400, 
                        lineHeight: 1.8, 
                        color: isImageBright ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.95)', 
                        textShadow: isImageBright ? 'none' : '0 1px 3px rgba(0,0,0,0.3)',
                        opacity: dissolveOpacity, 
                        filter: `blur(${(1-dissolveOpacity)*8}px)`, 
                        transition: 'opacity 2s ease-out, filter 2s ease-out',
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word'
                      }}>
                        {dissolveText}
                      </p>
                    </div>
                  )}
                  {showMergedMessage && (
                    <div style={{ 
                      width: '100%',
                      minHeight: 150,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}>
                      <p className="font-ui" style={{ 
                        margin: 0, 
                        fontSize: 14, 
                        color: isImageBright ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.85)',
                        opacity: mergedMessageOpacity,
                        transition: 'opacity 0.5s ease-out'
                      }}>
                        Your trace forms the image
                      </p>
                    </div>
                  )}
                </div>
                {!showMergedMessage && !dissolving && (
                  <div style={{ height: 40, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <button 
                      onClick={handleSubmitComment} 
                      onMouseEnter={() => setHoveredElement('submit')} 
                      onMouseLeave={() => setHoveredElement(null)}
                      style={{ 
                        background: 'none', 
                        border: 'none', 
                        padding: 8, 
                        cursor: 'pointer', 
                        color: isHovering('submit') ? '#0b385f' : (isImageBright ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.8)'),
                        transition: 'color 0.2s'
                      }}
                    >
                      <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="1.5">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 19.5l15-15m0 0H8.25m11.25 0v11.25"/>
                      </svg>
                    </button>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Contact sheet */}
          {showContactSheet && (
            <div className="fixed inset-0 z-50" style={{ overflow: 'hidden', backgroundColor: '#FAF9F6' }}
              onClick={() => { if (draggingIndex === null && !isLongPress.current) setShowContactSheet(false); }}>
              
              {!isMobile && <CustomCursor isClickable={hoveredElement !== null || hoveredThumbnail !== null} />}
              
              <button onClick={(e) => { e.stopPropagation(); setShowContactSheet(false); }}
                onMouseEnter={() => setHoveredElement('closeContact')} onMouseLeave={() => setHoveredElement(null)}
                className="absolute top-4 right-4 z-[60] transition-all" 
                style={{ color: isHovering('closeContact') ? '#0b385f' : '#333333', opacity: isHovering('closeContact') ? 1 : 0.5 }}>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
              <p className="font-ui absolute bottom-4 left-1/2 transform -translate-x-1/2 z-[60]"
                style={{ pointerEvents: 'none', fontSize: isMobile ? 11 : 12, opacity: 0.7, color: '#333333' }}>
                Reorder freely
              </p>
              <div className="w-full h-full relative">
                {photos.map((photo, index) => {
                  const pos = imagePositions[index];
                  if (!pos) return null;
                  const isOtherHovered = hoveredThumbnail !== null && hoveredThumbnail !== index;
                  const isDragging = draggingIndex === index;
                  const zIndex = zIndexOrder.indexOf(index) + 1;
                  
                  return (
                    <div key={photo.id} className="absolute" style={{
                      left: pos.x, top: pos.y, width: pos.width,
                      filter: isOtherHovered && !isDragging ? 'blur(2px)' : 'none',
                      opacity: isOtherHovered && !isDragging ? 0.5 : 1,
                      zIndex: isDragging || pinchingIndex === index ? 100 : zIndex,
                      transition: isDragging || pinchingIndex === index ? 'none' : 'filter 0.3s, opacity 0.3s',
                      transform: isDragging ? 'scale(1.05)' : 'scale(1)',
                      cursor: isMobile ? 'default' : 'grab', 
                      touchAction: 'none'
                    }}
                      onMouseDown={(e) => !isMobile && handleImageMouseDown(e, index)}
                      onMouseUp={(e) => !isMobile && handleImageMouseUp(e, index)}
                      onMouseEnter={() => !isMobile && setHoveredThumbnail(index)}
                      onMouseLeave={() => !isMobile && setHoveredThumbnail(null)}
                      onTouchStart={(e) => handleImageTouchStart(e, index)}
                      onTouchMove={(e) => handleImageTouchMove(e, index)}
                      onTouchEnd={(e) => handleImageTouchEnd(e, index)}>
                      <img src={photo.url} alt={photo.title} className="w-full h-auto object-cover pointer-events-none"
                        style={{ boxShadow: isDragging ? '0 8px 30px rgba(0,0,0,0.25)' : '0 2px 10px rgba(0,0,0,0.1)', userSelect: 'none' }} draggable={false} />
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Comments view */}
          {showCommentsView && currentPhoto && (
            <div className="fixed inset-0 z-50" style={{ overflow: 'hidden', cursor: isMobile ? 'auto' : 'none', backgroundColor: '#FAF9F6' }}
              onClick={() => setShowCommentsView(false)}>
              {!isMobile && <CustomCursor isClickable={hoveredElement !== null} />}
              <button onClick={(e) => { e.stopPropagation(); setShowCommentsView(false); }}
                onMouseEnter={() => setHoveredElement('closeComments')} onMouseLeave={() => setHoveredElement(null)}
                className="absolute z-[60] transition-all" style={{ top: 24, right: 24, color: isHovering('closeComments') ? '#0b385f' : '#333333', opacity: isHovering('closeComments') ? 1 : 0.5 }}>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
              <div className="w-full h-full overflow-auto" style={{ padding: 24 }}>
                <div className="font-body" style={{ fontSize: 9, lineHeight: 2, color: '#333333', opacity: 0.7, wordWrap: 'break-word' }}>
                  {photoComments[currentPhoto.id]?.length > 0 ? (
                    photoComments[currentPhoto.id].map((comment, idx) => (
                      <span key={idx}>{comment}{idx < photoComments[currentPhoto.id].length - 1 && ' _ '}</span>
                    ))
                  ) : <span style={{ opacity: 0.4 }}>No thoughts shared yet</span>}
                </div>
              </div>
            </div>
          )}

          {/* Screensaver */}
          {showScreensaver && (
            <div className="fixed inset-0 z-[200]" style={{ backgroundColor: 'rgba(250,249,246,0.95)' }}
              onClick={() => setShowScreensaver(false)}>
              <video
                autoPlay
                loop
                muted
                playsInline
                style={{
                  position: 'absolute',
                  left: screensaverPosition.x,
                  top: screensaverPosition.y,
                  width: '70%',
                  height: 'auto',
                  maxHeight: '70%',
                  objectFit: 'contain'
                }}
              >
                <source src={`https://raw.githubusercontent.com/${githubUser}/${githubRepo}/${githubBranch}/Paramo.mp4`} type="video/mp4" />
              </video>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<PhotoViewer />);
  </script>
</body>
</html>
