<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <title>Silent Fragments</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --classic-blue: #0f4c81;
    }
    body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      cursor: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      background: white;
    }
    html {
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      background: white;
    }
    img {
      pointer-events: none;
      -webkit-user-drag: none;
    }
    * {
      cursor: none !important;
      box-sizing: border-box;
    }
    /* Prevent iOS zoom and scroll */
    input, textarea {
      font-size: 16px !important;
    }
    /* Hide content until React loads */
    #root:empty {
      display: none;
    }
    #root {
      opacity: 0;
      animation: fadeIn 0.3s ease-in forwards;
      animation-delay: 0.1s;
    }
    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }
  </style>
</head>
<body oncontextmenu="return false;">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const PhotoViewer = () => {
      const projectTitle = "Silent Fragments";
      const githubUser = "jpbgd";
      const githubRepo = "Silent-fragments";
      const githubBranch = "main";

      const [photos, setPhotos] = useState([]);
      const [loading, setLoading] = useState(true);
      const [showIntro, setShowIntro] = useState(true);
      const [isZooming, setIsZooming] = useState(false);
      const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);
      const [randomOrder, setRandomOrder] = useState([]);
      const [showCommentBox, setShowCommentBox] = useState(false);
      const [commentText, setCommentText] = useState('');
      const [dissolving, setDissolving] = useState(false);
      const [dissolveText, setDissolveText] = useState('');
      const [dissolveOpacity, setDissolveOpacity] = useState(1);
      const [showMergedMessage, setShowMergedMessage] = useState(false);
      const [showContactSheet, setShowContactSheet] = useState(false);
      const [hoveredThumbnail, setHoveredThumbnail] = useState(null);
      const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });
      const [isHoveringClickable, setIsHoveringClickable] = useState(false);
      const [hoveredElement, setHoveredElement] = useState(null);
      const [isMobile, setIsMobile] = useState(false);
      const [isImageBright, setIsImageBright] = useState(false);
      const [photoComments, setPhotoComments] = useState({});
      const [showCommentsView, setShowCommentsView] = useState(false);
      const [imageLoaded, setImageLoaded] = useState(false);
      
      const MAX_COMMENTS_PER_PHOTO = 500; // Límite de comentarios antes de overwrite
      const STORAGE_KEY = 'silentFragmentsComments';

      // Cargar comentarios del localStorage al inicio
      useEffect(() => {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            setPhotoComments(JSON.parse(saved));
          }
        } catch (e) {
          console.log('Could not load comments from storage');
        }
      }, []);

      // Guardar comentarios en localStorage cuando cambien
      useEffect(() => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(photoComments));
        } catch (e) {
          console.log('Could not save comments to storage');
        }
      }, [photoComments]);
      
      // Contact sheet draggable positions
      const [imagePositions, setImagePositions] = useState([]);
      const [draggingIndex, setDraggingIndex] = useState(null);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
      const [zIndexOrder, setZIndexOrder] = useState([]);
      const longPressTimer = useRef(null);
      const [isLongPress, setIsLongPress] = useState(false);
      const wasDragging = useRef(false);
      
      // Pinch zoom for contact sheet
      const [pinchingIndex, setPinchingIndex] = useState(null);
      const initialPinchDistance = useRef(0);
      const initialImageWidth = useRef(0);
      const initialPinchCenter = useRef({ x: 0, y: 0 });
      const initialImagePos = useRef({ x: 0, y: 0 });
      
      const touchStartX = useRef(0);
      const touchStartY = useRef(0);
      const touchStartTime = useRef(0);
      const lastPhotoChangeTime = useRef(0);
      const isChangingPhoto = useRef(false);

      // Detect mobile
      useEffect(() => {
        const checkMobile = () => {
          setIsMobile(window.innerWidth <= 768 || 'ontouchstart' in window);
        };
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
      }, []);

      // Initialize image positions for contact sheet
      const initializePositions = () => {
        const isMobileView = window.innerWidth <= 768;
        const positions = photos.map((_, index) => {
          if (isMobileView) {
            // Mobile: smaller images, scattered layout
            const cols = 2;
            const row = Math.floor(index / cols);
            const col = index % cols;
            return {
              x: 20 + col * (window.innerWidth * 0.4) + (Math.random() - 0.5) * 30,
              y: 60 + row * (window.innerHeight * 0.25) + (Math.random() - 0.5) * 20,
              width: window.innerWidth * 0.35
            };
          } else {
            // Desktop: original scattered layout
            const basePositions = [
              { x: window.innerWidth * 0.1, y: window.innerHeight * 0.05, width: window.innerWidth * 0.28 },
              { x: window.innerWidth * 0.55, y: window.innerHeight * 0.1, width: window.innerWidth * 0.32 },
              { x: window.innerWidth * 0.05, y: window.innerHeight * 0.4, width: window.innerWidth * 0.25 },
              { x: window.innerWidth * 0.5, y: window.innerHeight * 0.55, width: window.innerWidth * 0.28 },
              { x: window.innerWidth * 0.3, y: window.innerHeight * 0.65, width: window.innerWidth * 0.3 }
            ];
            return basePositions[index % basePositions.length];
          }
        });
        setImagePositions(positions);
        setZIndexOrder(photos.map((_, i) => i));
      };

      useEffect(() => {
        if (photos.length > 0 && showContactSheet) {
          initializePositions();
        }
      }, [photos, showContactSheet]);

      useEffect(() => {
        const photoFiles = [
          'Untitled_250619.jpg',
          'Untitled_241221.jpg',
          'Untitiled_241208.jpg',
          'Untitiled_241115.jpg',
          'Untitiled_240714.jpg'
        ];
        
        const photosList = photoFiles.map((fileName, index) => {
          const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
          const parts = nameWithoutExt.split('_');
          const title = parts[0] || 'Untitled';
          const date = parts[1] || '';
          
          return {
            id: index,
            url: `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/${githubBranch}/${fileName}`,
            title: title,
            date: date
          };
        });
        
        setPhotos(photosList);
        setLoading(false);
      }, []);

      useEffect(() => {
        if (photos.length > 0) {
          const shuffled = [...Array(photos.length).keys()].sort(() => Math.random() - 0.5);
          setRandomOrder(shuffled);
        }
      }, [photos]);

      // Reset imageLoaded cuando cambia la foto
      useEffect(() => {
        setImageLoaded(false);
      }, [currentPhotoIndex]);

      useEffect(() => {
        const timer = setTimeout(() => {
          setShowIntro(false);
        }, 1500);
        return () => clearTimeout(timer);
      }, []);

      useEffect(() => {
        const handleMouseMove = (e) => {
          setCursorPosition({ x: e.clientX, y: e.clientY });
          
          const target = e.target;
          const isClickable = target.closest('button, a, .cursor-pointer') !== null;
          setIsHoveringClickable(isClickable);
          
          // Handle dragging on desktop
          if (draggingIndex !== null) {
            const newPositions = [...imagePositions];
            newPositions[draggingIndex] = {
              ...newPositions[draggingIndex],
              x: e.clientX - dragOffset.x,
              y: e.clientY - dragOffset.y
            };
            setImagePositions(newPositions);
          }
        };

        const handleMouseUp = () => {
          setDraggingIndex(null);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [draggingIndex, dragOffset, imagePositions]);

      const handleTouchStart = (e) => {
        if (e.touches.length > 1) {
          setIsZooming(true);
          return;
        }
        touchStartX.current = e.touches[0].clientX;
        touchStartY.current = e.touches[0].clientY;
        touchStartTime.current = Date.now();
      };

      const handleTouchEnd = (e) => {
        if (isZooming) {
          setIsZooming(false);
          return;
        }
        
        // Si hay más de un dedo, es zoom - no cambiar imagen
        if (e.touches && e.touches.length > 0) {
          return;
        }
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const diffX = Math.abs(touchStartX.current - touchEndX);
        const diffY = Math.abs(touchStartY.current - touchEndY);
        const touchDuration = Date.now() - touchStartTime.current;

        // Solo cambiar imagen con tap (movimiento menor a 10px y duración menor a 300ms)
        if (diffX < 10 && diffY < 10 && touchDuration < 300) {
          e.preventDefault();
          e.stopPropagation();
          handleNextPhoto();
        }
      };

      // Prevenir onClick en móvil ya que usamos touch events
      const handleImageClick = (e) => {
        if (!isMobile) {
          handleNextPhoto();
        }
      };

      const handleNextPhoto = () => {
        const now = Date.now();
        // Prevenir cambios muy rápidos (debounce de 300ms)
        if (now - lastPhotoChangeTime.current < 300 || isChangingPhoto.current) {
          return;
        }
        
        isChangingPhoto.current = true;
        lastPhotoChangeTime.current = now;
        
        setShowMergedMessage(false);
        setCurrentPhotoIndex((prev) => (prev + 1) % randomOrder.length);
        
        // Reset flag después de la transición
        setTimeout(() => {
          isChangingPhoto.current = false;
        }, 100);
      };

      // Detectar brillo de la imagen actual
      useEffect(() => {
        if (!currentPhoto) return;
        
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = currentPhoto.url;
        
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Usar tamaño pequeño para análisis rápido
          const size = 50;
          canvas.width = size;
          canvas.height = size;
          
          ctx.drawImage(img, 0, 0, size, size);
          
          try {
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            let totalBrightness = 0;
            
            for (let i = 0; i < data.length; i += 4) {
              // Calcular luminosidad percibida
              const brightness = (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
              totalBrightness += brightness;
            }
            
            const avgBrightness = totalBrightness / (size * size);
            setIsImageBright(avgBrightness > 140); // Si es mayor a 140, es brillante
          } catch (e) {
            // Si falla el análisis (CORS), asumir imagen oscura
            setIsImageBright(false);
          }
        };
      }, [currentPhoto]);

      const handleTitleClick = (e) => {
        e.stopPropagation();
        setShowIntro(true);
        setTimeout(() => {
          setShowIntro(false);
        }, 3000);
      };

      const handleThumbnailClick = (index) => {
        // Solo maximizar si NO fue un drag y NO es long press
        if (!isLongPress && !wasDragging.current) {
          setCurrentPhotoIndex(randomOrder.indexOf(index));
          setShowContactSheet(false);
        }
        // Reset flags
        setIsLongPress(false);
        wasDragging.current = false;
      };

      // Desktop drag handlers
      const handleImageMouseDown = (e, index) => {
        e.preventDefault();
        e.stopPropagation();
        
        setDragOffset({
          x: e.clientX - imagePositions[index].x,
          y: e.clientY - imagePositions[index].y
        });
        setDraggingIndex(index);
        wasDragging.current = true;
        
        // Bring to front
        setZIndexOrder(prev => {
          const newOrder = prev.filter(i => i !== index);
          return [...newOrder, index];
        });
      };

      // Mobile touch drag handlers for contact sheet
      const handleImageTouchStart = (e, index) => {
        // Cancelar cualquier timer previo
        if (longPressTimer.current) {
          clearTimeout(longPressTimer.current);
        }
        
        // Si hay 2 dedos, es pinch zoom
        if (e.touches.length === 2) {
          e.preventDefault();
          e.stopPropagation();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          
          initialPinchDistance.current = distance;
          initialImageWidth.current = imagePositions[index]?.width || 100;
          initialPinchCenter.current = { x: centerX, y: centerY };
          initialImagePos.current = { 
            x: imagePositions[index]?.x || 0, 
            y: imagePositions[index]?.y || 0 
          };
          setPinchingIndex(index);
          setDraggingIndex(null);
          setIsLongPress(false);
          
          // Bring to front
          setZIndexOrder(prev => {
            const newOrder = prev.filter(i => i !== index);
            return [...newOrder, index];
          });
          return;
        }
        
        const touch = e.touches[0];
        
        // Start long press timer - reducido a 150ms para que sea más natural
        longPressTimer.current = setTimeout(() => {
          setIsLongPress(true);
          wasDragging.current = true;
          setDragOffset({
            x: touch.clientX - imagePositions[index].x,
            y: touch.clientY - imagePositions[index].y
          });
          setDraggingIndex(index);
          
          // Bring to front
          setZIndexOrder(prev => {
            const newOrder = prev.filter(i => i !== index);
            return [...newOrder, index];
          });
        }, 150);
      };

      const handleImageTouchMove = (e, index) => {
        // Si se detectan 2 dedos durante el move, manejar pinch zoom + drag
        if (e.touches.length === 2) {
          e.preventDefault();
          e.stopPropagation();
          
          // Cancelar drag si estaba activo
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
          }
          setDraggingIndex(null);
          setIsLongPress(false);
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          
          // Si es el inicio del pinch, guardar distancia inicial
          if (pinchingIndex !== index) {
            initialPinchDistance.current = distance;
            initialImageWidth.current = imagePositions[index]?.width || 100;
            initialPinchCenter.current = { x: centerX, y: centerY };
            initialImagePos.current = { 
              x: imagePositions[index]?.x || 0, 
              y: imagePositions[index]?.y || 0 
            };
            setPinchingIndex(index);
            
            // Bring to front
            setZIndexOrder(prev => {
              const newOrder = prev.filter(i => i !== index);
              return [...newOrder, index];
            });
          } else {
            // Continuar el pinch zoom + movimiento
            const scale = distance / initialPinchDistance.current;
            const newWidth = Math.max(60, Math.min(window.innerWidth * 0.9, initialImageWidth.current * scale));
            
            // Calcular el movimiento del centro del pinch
            const deltaX = centerX - initialPinchCenter.current.x;
            const deltaY = centerY - initialPinchCenter.current.y;
            
            const newPositions = [...imagePositions];
            newPositions[index] = {
              ...newPositions[index],
              width: newWidth,
              x: initialImagePos.current.x + deltaX,
              y: initialImagePos.current.y + deltaY
            };
            setImagePositions(newPositions);
          }
          return;
        }
        
        // Handle drag con un dedo
        if (draggingIndex === index && e.touches.length === 1) {
          e.preventDefault();
          const touch = e.touches[0];
          const newPositions = [...imagePositions];
          newPositions[index] = {
            ...newPositions[index],
            x: touch.clientX - dragOffset.x,
            y: touch.clientY - dragOffset.y
          };
          setImagePositions(newPositions);
        } else if (e.touches.length === 1 && !isLongPress) {
          // Cancel long press if moved before timer
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
          }
        }
      };

      const handleImageTouchEnd = (e, index) => {
        if (longPressTimer.current) {
          clearTimeout(longPressTimer.current);
        }
        
        // Reset pinch zoom
        if (pinchingIndex === index) {
          setPinchingIndex(null);
          initialPinchDistance.current = 0;
          initialImageWidth.current = 0;
          initialPinchCenter.current = { x: 0, y: 0 };
          initialImagePos.current = { x: 0, y: 0 };
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        
        if (draggingIndex === index) {
          e.preventDefault();
          e.stopPropagation();
          setDraggingIndex(null);
          // Keep wasDragging true so click doesn't fire
          setTimeout(() => {
            setIsLongPress(false);
            wasDragging.current = false;
          }, 100);
        }
      };

      const handleSubmitComment = () => {
        if (!commentText.trim()) return;

        const textToSave = commentText.trim();
        setDissolveText(textToSave);
        setCommentText('');
        setDissolving(true);
        setDissolveOpacity(1);

        // Guardar el comentario en el estado de la imagen
        const currentPhoto = photos[randomOrder[currentPhotoIndex]];
        const photoId = currentPhoto.id;
        setPhotoComments(prev => {
          const currentComments = prev[photoId] || [];
          let newComments;
          
          // Si excede el límite, empezar a sobrescribir desde el principio
          if (currentComments.length >= MAX_COMMENTS_PER_PHOTO) {
            newComments = [...currentComments.slice(1), textToSave];
          } else {
            newComments = [...currentComments, textToSave];
          }
          
          return {
            ...prev,
            [photoId]: newComments
          };
        });

        console.log('Comment saved:', {
          photoId: photoId,
          photoTitle: currentPhoto.title,
          photoDate: currentPhoto.date,
          text: textToSave,
          timestamp: new Date().toISOString()
        });

        // Iniciar el fade out inmediatamente
        requestAnimationFrame(() => {
          setDissolveOpacity(0);
        });

        // Después de 2.25 segundos de fade, mostrar mensaje inmediatamente
        setTimeout(() => {
          setShowMergedMessage(true);
          setDissolving(false);
          setDissolveText('');
          
          // Mostrar mensaje durante 0.8 segundos y luego cerrar
          setTimeout(() => {
            setShowMergedMessage(false);
            setShowCommentBox(false);
          }, 800);
        }, 2250);
      };

      if (loading) {
        return (
          <div className="w-screen h-screen bg-white flex items-center justify-center overflow-hidden fixed inset-0">
            <p className="text-gray-900 text-sm">Loading...</p>
          </div>
        );
      }

      if (photos.length === 0 || randomOrder.length === 0) {
        return (
          <div className="w-screen h-screen bg-white flex items-center justify-center overflow-hidden fixed inset-0">
            <p className="text-gray-900 text-sm">No photos found</p>
          </div>
        );
      }

      const currentPhoto = photos[randomOrder[currentPhotoIndex]];

      return (
        <div 
          className="w-screen bg-white relative" 
          style={{ 
            cursor: 'none',
            overflow: 'hidden',
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            height: '100%',
            width: '100%',
            touchAction: 'manipulation'
          }}
        >
          {/* Custom cursor - hide on mobile */}
          {!isMobile && (
            <div
              className="fixed pointer-events-none"
              style={{
                left: `${cursorPosition.x}px`,
                top: `${cursorPosition.y}px`,
                transform: 'translate(-50%, -50%)',
                width: '10px',
                height: '10px',
                backgroundColor: isHoveringClickable ? '#0f4c81' : 'rgba(0, 0, 0, 0.4)',
                borderRadius: '50%',
                transition: 'background-color 0.2s ease',
                zIndex: 10000
              }}
            />
          )}

          <div
            className={`absolute inset-0 bg-white flex items-center justify-center z-50 ${
              showIntro ? 'opacity-100' : 'opacity-0'
            }`}
            style={{ 
              transition: 'opacity 2000ms ease-out',
              pointerEvents: showIntro ? 'auto' : 'none'
            }}
          >
            <h1 className="text-gray-900 text-2xl md:text-4xl font-light tracking-wider px-4 text-center">
              {projectTitle}
            </h1>
          </div>

          {!showIntro && currentPhoto && (
            <div 
              className="w-full flex flex-col items-center justify-between"
              style={{
                height: '100%',
                padding: isMobile ? '12px 12px 8px 12px' : '24px',
                overflow: 'hidden'
              }}
            >
              <div 
                className="w-full text-center cursor-pointer flex-shrink-0" 
                onClick={handleTitleClick}
                onMouseEnter={() => setHoveredElement('title')}
                onMouseLeave={() => setHoveredElement(null)}
              >
                <h2 
                  className="text-sm md:text-base font-light tracking-wide transition-all"
                  style={{ 
                    color: hoveredElement === 'title' ? '#0f4c81' : '#111827',
                    opacity: hoveredElement === 'title' ? 1 : 0.7
                  }}
                >
                  {projectTitle}
                </h2>
              </div>

              <div 
                className="flex items-center justify-center w-full cursor-pointer"
                style={{ 
                  flex: '1 1 auto',
                  maxWidth: isMobile ? '100%' : '42rem',
                  minHeight: 0,
                  overflow: 'hidden',
                  padding: isMobile ? '8px 0' : '16px 0'
                }}
                onTouchStart={handleTouchStart}
                onTouchEnd={handleTouchEnd}
                onClick={handleImageClick}
              >
                <img
                  src={currentPhoto.url}
                  alt={currentPhoto.title}
                  className="object-contain"
                  onLoad={() => setImageLoaded(true)}
                  style={{ 
                    maxWidth: '100%',
                    maxHeight: '100%',
                    boxShadow: '0 4px 30px rgba(0, 0, 0, 0.12)',
                    touchAction: 'pan-x pan-y pinch-zoom',
                    opacity: imageLoaded ? 1 : 0,
                    transition: 'opacity 0.5s ease-in'
                  }}
                />
              </div>

              <div 
                className="w-full flex-shrink-0"
                style={{
                  paddingTop: isMobile ? '8px' : '12px',
                  position: 'relative',
                  zIndex: 5
                }}
              >
                <div className="flex items-center w-full">
                  <div className="flex-1 flex justify-start">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setShowContactSheet(true);
                      }}
                      onMouseEnter={() => setHoveredElement('contactSheet')}
                      onMouseLeave={() => setHoveredElement(null)}
                      className="transition-all"
                      style={{ 
                        color: hoveredElement === 'contactSheet' ? '#0f4c81' : '#111827',
                        opacity: hoveredElement === 'contactSheet' ? 1 : 0.7
                      }}
                    >
                      <svg width={isMobile ? "16" : "16"} height={isMobile ? "16" : "16"} viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="7" cy="7" r="2.5"/>
                        <circle cx="17" cy="7" r="2.5"/>
                        <circle cx="7" cy="17" r="2.5"/>
                        <circle cx="17" cy="17" r="2.5"/>
                      </svg>
                    </button>
                  </div>
                  <div className="flex-1 flex justify-center">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setShowCommentBox(true);
                      }}
                      onMouseEnter={() => setHoveredElement('share')}
                      onMouseLeave={() => setHoveredElement(null)}
                      className="font-light transition-all"
                      style={{ 
                        fontSize: isMobile ? '11px' : '12px',
                        color: hoveredElement === 'share' ? '#0f4c81' : '#111827',
                        opacity: hoveredElement === 'share' ? 1 : 0.7
                      }}
                    >
                      Share your thoughts
                    </button>
                  </div>
                  <div className="flex-1 flex justify-end">
                    <button 
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        setShowCommentsView(true);
                      }}
                      onMouseEnter={() => setHoveredElement('photoTitle')}
                      onMouseLeave={() => setHoveredElement(null)}
                      className="font-light italic transition-all text-right"
                      style={{ 
                        fontSize: isMobile ? '11px' : '12px',
                        color: hoveredElement === 'photoTitle' ? '#0f4c81' : '#111827',
                        opacity: hoveredElement === 'photoTitle' ? 1 : 0.7,
                        background: 'none',
                        border: 'none',
                        padding: '4px',
                        margin: '-4px',
                        cursor: isMobile ? 'pointer' : 'none',
                        pointerEvents: 'auto',
                        position: 'relative',
                        zIndex: 10
                      }}
                    >
                      {currentPhoto.title}, {currentPhoto.date}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {showCommentBox && (
            <div
              className="fixed z-50"
              style={{
                backgroundColor: 'rgba(255, 255, 255, 0.02)',
                backdropFilter: 'blur(0.5px)',
                WebkitBackdropFilter: 'blur(0.5px)',
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                height: '100%',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
              onClick={() => setShowCommentBox(false)}
            >
              <div 
                className="w-11/12 max-w-md text-center" 
                onClick={(e) => e.stopPropagation()}
              >
                <div className="relative h-32">
                  <div className="absolute inset-0 flex items-center justify-center">
                    {!showMergedMessage && !dissolving ? (
                      <>
                        {!commentText && (
                          <span 
                            className="text-sm absolute pointer-events-none font-light"
                            style={{ 
                              color: isImageBright ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.85)',
                              textShadow: isImageBright ? 'none' : '0 1px 3px rgba(0,0,0,0.3)'
                            }}
                          >
                            write down what you're thinking...
                          </span>
                        )}
                        <textarea
                          value={commentText}
                          onChange={(e) => setCommentText(e.target.value)}
                          className="w-full h-full bg-transparent border-none outline-none resize-none text-sm text-center font-light"
                          style={{ 
                            lineHeight: '128px', 
                            cursor: isMobile ? 'auto' : 'none',
                            color: isImageBright ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.95)',
                            textShadow: isImageBright ? 'none' : '0 1px 3px rgba(0,0,0,0.3)',
                            fontSize: '16px'
                          }}
                          autoFocus
                        />
                      </>
                    ) : dissolving ? (
                      <p 
                        className="text-lg font-light"
                        style={{ 
                          color: isImageBright ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.95)',
                          textShadow: isImageBright ? 'none' : '0 1px 3px rgba(0,0,0,0.3)',
                          opacity: dissolveOpacity,
                          filter: `blur(${(1 - dissolveOpacity) * 10}px)`,
                          transform: `scale(${1 + (1 - dissolveOpacity) * 0.15})`,
                          transition: 'opacity 2.25s ease-out, filter 2.25s ease-out, transform 2.25s ease-out'
                        }}
                      >
                        {dissolveText}
                      </p>
                    ) : (
                      <p 
                        className="text-sm font-light"
                        style={{ 
                          color: isImageBright ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.85)'
                        }}
                      >
                        Words merged with image work
                      </p>
                    )}
                  </div>
                </div>
                <div className="flex justify-center mt-4" style={{ height: '24px' }}>
                  {!showMergedMessage && !dissolving && (
                    <button 
                      onClick={handleSubmitComment} 
                      className="opacity-70 hover:opacity-100"
                      style={{ 
                        color: isImageBright ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.9)'
                      }}
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="1.5">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 19.5l15-15m0 0H8.25m11.25 0v11.25"/>
                      </svg>
                    </button>
                  )}
                </div>
              </div>
            </div>
          )}

          {showContactSheet && (
            <div 
              className="fixed inset-0 bg-white z-50" 
              style={{ overflow: 'hidden' }}
              onClick={() => {
                if (draggingIndex === null && !isLongPress) {
                  setShowContactSheet(false);
                }
              }}
            >
              {/* Close button */}
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setShowContactSheet(false);
                }}
                className="absolute top-4 right-4 z-[60] text-gray-900 opacity-50 hover:opacity-100 transition-opacity"
              >
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
              
              {/* Hint text */}
              <p 
                className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-gray-900 font-light z-[60]"
                style={{ 
                  pointerEvents: 'none',
                  fontSize: isMobile ? '11px' : '12px',
                  opacity: 0.7
                }}
              >
                {isMobile ? 'Hold & drag to reorder freely • Tap to view' : 'Click & drag to reorder freely • Click to view'}
              </p>

              <div className="w-full h-full relative">
                {photos.map((photo, index) => {
                  const pos = imagePositions[index];
                  if (!pos) return null;
                  
                  const isOtherHovered = hoveredThumbnail !== null && hoveredThumbnail !== index;
                  const isDragging = draggingIndex === index;
                  const zIndex = zIndexOrder.indexOf(index) + 1;
                  
                  return (
                    <div
                      key={photo.id}
                      className="absolute cursor-pointer transition-shadow duration-300"
                      style={{
                        left: `${pos.x}px`,
                        top: `${pos.y}px`,
                        width: `${pos.width}px`,
                        filter: isOtherHovered && !isDragging ? 'blur(4px)' : 'blur(0px)',
                        opacity: isOtherHovered && !isDragging ? 0.3 : 1,
                        zIndex: isDragging || pinchingIndex === index ? 100 : zIndex,
                        transition: isDragging || pinchingIndex === index ? 'none' : 'filter 0.3s, opacity 0.3s',
                        transform: isDragging ? 'scale(1.05)' : 'scale(1)',
                        cursor: isMobile ? 'default' : 'grab',
                        touchAction: 'none'
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        // Solo si no estaba arrastrando
                        if (!wasDragging.current && !isLongPress) {
                          handleThumbnailClick(index);
                        }
                      }}
                      onMouseDown={(e) => !isMobile && handleImageMouseDown(e, index)}
                      onMouseUp={(e) => {
                        if (!isMobile && draggingIndex === index) {
                          e.stopPropagation();
                          setDraggingIndex(null);
                          // Prevenir click después de drag
                          setTimeout(() => {
                            wasDragging.current = false;
                          }, 100);
                        }
                      }}
                      onMouseEnter={() => !isMobile && setHoveredThumbnail(index)}
                      onMouseLeave={() => !isMobile && setHoveredThumbnail(null)}
                      onTouchStart={(e) => handleImageTouchStart(e, index)}
                      onTouchMove={(e) => handleImageTouchMove(e, index)}
                      onTouchEnd={(e) => handleImageTouchEnd(e, index)}
                    >
                      <img
                        src={photo.url}
                        alt={photo.title}
                        className="w-full h-auto object-cover pointer-events-none"
                        style={{ 
                          boxShadow: isDragging 
                            ? '0 8px 30px rgba(0, 0, 0, 0.25)' 
                            : '0 2px 10px rgba(0, 0, 0, 0.1)',
                          userSelect: 'none'
                        }}
                        draggable={false}
                      />
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {showCommentsView && currentPhoto && (
            <div 
              className="fixed inset-0 bg-white z-50"
              style={{ 
                overflow: 'hidden',
                cursor: isMobile ? 'auto' : 'none'
              }}
              onClick={() => setShowCommentsView(false)}
            >
              {/* Custom cursor for comments view */}
              {!isMobile && (
                <div
                  className="fixed pointer-events-none"
                  style={{
                    left: `${cursorPosition.x}px`,
                    top: `${cursorPosition.y}px`,
                    transform: 'translate(-50%, -50%)',
                    width: '10px',
                    height: '10px',
                    backgroundColor: 'rgba(0, 0, 0, 0.4)',
                    borderRadius: '50%',
                    zIndex: 10001
                  }}
                />
              )}
              
              {/* Close button */}
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setShowCommentsView(false);
                }}
                onMouseEnter={() => setHoveredElement('closeComments')}
                onMouseLeave={() => setHoveredElement(null)}
                className="absolute z-[60] transition-all"
                style={{
                  top: '24px',
                  right: '24px',
                  color: hoveredElement === 'closeComments' ? '#0f4c81' : '#111827',
                  opacity: hoveredElement === 'closeComments' ? 1 : 0.5
                }}
              >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>

              {/* Comments content */}
              <div 
                className="w-full h-full overflow-auto"
                style={{ 
                  padding: isMobile ? '24px' : '24px',
                  paddingTop: isMobile ? '24px' : '24px'
                }}
              >
                <div 
                  className="font-light"
                  style={{ 
                    fontSize: '8px',
                    lineHeight: '1.8',
                    color: '#111827',
                    opacity: 0.7,
                    maxWidth: '100%',
                    wordWrap: 'break-word',
                    fontFamily: 'inherit'
                  }}
                >
                  {photoComments[currentPhoto.id] && photoComments[currentPhoto.id].length > 0 ? (
                    photoComments[currentPhoto.id].map((comment, idx) => (
                      <span key={idx}>
                        {comment}
                        {idx < photoComments[currentPhoto.id].length - 1 && ' _ '}
                      </span>
                    ))
                  ) : (
                    <span style={{ opacity: 0.4 }}>No thoughts shared yet</span>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PhotoViewer />);
  </script>
</body>
</html>
